#!/usr/bin/env python3
import sys
import subprocess as sp
import argparse
import os
import multiprocessing
import argcomplete

parser = argparse.ArgumentParser(description = '', formatter_class = argparse.RawTextHelpFormatter)

parser.add_argument('-l', dest = 'loop_list', required=True, type = str, help = 
'''loop list file cut by certain criteria, such as q<0.01.
Each file must include (chr1, bin1_start, bin2_start, chr2, chr2_start, chr2_end)
in their first 6 columns.

''')
parser.add_argument('-b', dest = 'bed_list', required=True, type = str, help = 
'''".bed" list file. The order of list must correct with loop list order.
At default setting, bed files are generated in "out_dir/tmp" directory.

''')
parser.add_argument('-o', dest = 'overlapbed_list', required=True, type = str, help = 
'''"overlap_bin.bed" list file. The order of list must correct with loop list order.
At default setting, "overlap_bin.bed" files are generated in "out_dir/tmp" directory.

''')
parser.add_argument('-p', dest = 'prefix', required=True, help = 
'''Output file name prefix. Output file path = {out_dir}/{prefix}-{overlap/expand}.{layers}.HiCORE.txt

''')
parser.add_argument('-d', dest = 'output_dir', default = './', help = '''Path to output directory. (default = "./")

''')
parser.add_argument('-t', dest = 'threads', default = 1, type=int, help = 
'''Number of threads. 
If thread >= layers, the running time is remarkably reduced but memory-intensive. (default = 1)

''')
parser.add_argument('-x', dest = 'cutoff', default = 0.20, type=float, help = '''The minimum detected-layer frequency of loops. (the number of detected layers / total layers). 0<=x<=1, default = 0.20

''')
parser.add_argument('-u', dest = 'unit_bed', required=True, help = '''1f_unit.bed file path. The file was generated by hicbinning.py at outdir/tmp directory

''')
parser.add_argument('-e', dest = 'exception', action='store_true', help = 
'''Except the loops with potential noise. 
With this option, HiCORE identifies the loops with the local maximum detected-layer frequency more strictly.
We recommand to use this option for more stringent analysis.

''')
argcomplete.autocomplete(parser)
args = parser.parse_args()


## Variable setting
bed_list_file = args.bed_list
loop_list_file = args.loop_list
overbed_list_file = args.overlapbed_list
out_dir = args.output_dir
prefix = args.prefix
t = args.threads
cutoff = args.cutoff
unit_bed = args.unit_bed
exception = args.exception

split_loop_list = []
binSizelist = []

with open(f'{bed_list_file}') as b1:
    bed_list = b1.readlines()
    first_layer_bed = bed_list[0].strip()
with open(f'{loop_list_file}') as l1:
    loop_list = l1.readlines()
    layer_num = len(loop_list)
    split_loop_list = []
    for filename in loop_list:
        split_loop_file = filename.strip() + '.splitbin.txt'
        split_loop_list.append(split_loop_file)
with open(f'{overbed_list_file}') as o1:
    overbed_list = o1.readlines()
    first_layer_overbed = overbed_list[0].strip()


def tmpClearing():
    if os.path.isdir(f'{out_dir}') == True:
        if os.path.isdir(f'{out_dir}/tmp') == False:
            os.mkdir(f'{out_dir}/tmp')
        elif os.listdir(f'{out_dir}/tmp') != []:
            print(f"\n******{out_dir}/tmp directory is not empty\n")
            sys.exit()
    else:
        os.mkdir(f'{out_dir}')
        os.mkdir(f'{out_dir}/tmp')


## Split the multi-fragments resolution loop files into single fragment resolution
def splitloop(bed_file, overbed_file, loop_file):
    mid_to_binnum = {}
    front_tag = '.'.join(loop_file.split('.')[:-1])

    ### mid point of loop : bin_num dictionary creation
    with open(f'{bed_file}'.strip()) as b1:
        bed_context = b1.readlines()

        for blines in bed_context:
    
            bsplit = blines.split('\t')
            chr_name = bsplit[0]
            mid_point = str(int((int(bsplit[1])+int(bsplit[2]))/2))
            bin_num = bsplit[3].strip()
            mid_to_binnum[chr_name + '\t' + mid_point] = bin_num

    ### (a multi-fragments bin number) : (intact bin of split fragments) dictionary  
    with open(f'{overbed_file}'.strip()) as o1:
        ocontext = o1.readlines()
        binnum_to_fulldic = {}
        obin_list = []

        a=0
        while a <= len(ocontext)-1:
            osplit = ocontext[a].split('\t')
            ofull_bin = '\t'.join(ocontext[a].split('\t')[:3])

            if a == 0:
                obin_list=[]
                obin_list.append(ofull_bin)
                obin_num = str(1)
            else:
                if osplit[3].strip() == obin_num:
                    obin_list.append(ofull_bin)
                    if a == len(ocontext)-1:
                        binnum_to_fulldic[obin_num] = obin_list
                        break
                else:
                    binnum_to_fulldic[obin_num] = obin_list
                    obin_list=[]
                    obin_num = osplit[3].strip()
                    obin_list.append(ofull_bin)
            
            a += 1

    with open(f'{loop_file}'.strip()) as l1:
        loop_context = l1.readlines()
        filename = loop_file.strip()
        writefinal = open(f'{filename}.splitbin.txt','w')

        for llines in loop_context:
            bin1 = '\t'.join(llines.split('\t')[:2])
            bin2 = '\t'.join(llines.split('\t')[2:4])

            full_bin1 = mid_to_binnum[bin1]
            full_bin2 = mid_to_binnum[bin2]

            for i in binnum_to_fulldic[full_bin1]:
                for j in binnum_to_fulldic[full_bin2]:
                    full_bin_out = i + '\t' + j + '\n'
                    writefinal.write(full_bin_out)

        writefinal.close()

## Collect all split loops
def collectLoop():
    cat_loop = ' '.join(split_loop_list)
    sp.call(f"cat {cat_loop} | sort -k1,1 -k2,2n -k5,5n | uniq -c | awk '{{print $2, $3, $4, $5, $6, $7, $1/{layer_num}}}' OFS='\t' > {out_dir}/tmp/{prefix}.allLoop.txt", shell=True, universal_newlines=True)

## Dictionary for genomic information : fragment of restriction fragments
def FragmentDic():
    global FragNumDic, NumFragDic  
    FragNumDic = {}
    NumFragDic = {}
    with open(unit_bed) as u1:
        for line in u1:
            fragment = '\t'.join(line.rstrip().split('\t')[0:3])
            number = line.rstrip().split('\t')[3]
            FragNumDic[fragment] = number
            NumFragDic[number] = fragment

## Merge all the connected loops
def DefineAnchor():
    global anchorLayerCountDic
    anchorLayerCountDic = {}
    loopList = []
    with open(f'{out_dir}/tmp/{prefix}.allLoop.txt') as l1:
        tmplist = []
        for line in l1:
            chr1, start1, end1, chr2, start2, end2, frequency = line.rstrip().split('\t')
            bin1 = FragNumDic[chr1 + '\t' + start1 + '\t' + end1]
            bin2 = FragNumDic[chr2 + '\t' + start2 + '\t' + end2]
            anchorLayerCountDic[bin1 + '\t' + bin2] = float(frequency)

            fixed_anchor = 'anchor1_' + bin1

            if tmplist == []:
                tmplist = [fixed_anchor,bin2]
            else:
                anchor1 = tmplist[0]
                anchor2 = int(tmplist[-1])

                if bin1 == anchor1.split('_')[-1] and abs(int(bin2) - anchor2) == 1:
                    tmplist.append(bin2)
                else:
                    loopList.append(tmplist)
                    tmplist = [fixed_anchor, bin2]

        loopList.append(tmplist)
        global mergedLoop_list
        mergedLoop_list = []

        while len(loopList) > 0:
            loop = loopList[0]
            tmplist = []
            startloop = []
            anchor1 = loop[0].split('_')[-1]
            loopList.pop(0)

            if len(loopList) == 0:
                for last_anchor in loop:
                    if 'anchor' not in last_anchor:
                        tmplist.append(anchor1 + '\t' + last_anchor)
                mergedLoop_list.append(tmplist)
                break
            else:
                for anchor2 in loop:
                    if 'anchor' not in anchor2:
                        startloop.append(anchor1 + '\t' + anchor2)
                        tmplist.append(anchor1 + '\t' + anchor2)
            
            a=1
            break_1 = False           
            while 1:
                
                i=0
                while 1:
                    if tmplist == startloop:
                        previous_loop = loop
                    elif i == len(loopList):
                        mergedLoop_list.append(tmplist)
                        break
                    else:
                        previous_loop = tmpanchor2

                    screening_loop = loopList[i]
                    screening_anchor = screening_loop[0].split('_')[-1]

                    if int(screening_anchor) < int(anchor1) + a:
                        i = i + 1
                        continue

                    elif int(screening_anchor) == int(anchor1) + a:
                        for original_anchor2 in previous_loop:
                            if original_anchor2 in screening_loop and 'anchor' not in original_anchor2:

                                ## Merge the neighboring fragments
                                tmpanchor2 = []
                                for next_anchor2 in screening_loop:
                                    if 'anchor' not in next_anchor2:
                                        
                                        tmplist.append(screening_anchor + '\t' + next_anchor2)
                                        tmpanchor2.append(next_anchor2)
                                loopList.remove(screening_loop)        
                                break_1 = True
                                i = i - 1
                                break
                        i = i + 1
                        if len(loopList) == 0:
                            mergedLoop_list.append(tmplist)
                            break
                        continue
                    else:
                        break

                if len(loopList) == 0 or i == len(loopList):
                    break
                elif break_1 == False:
                    mergedLoop_list.append(tmplist)
                    break
                else:
                    a = a + 1
                    break_1 = False
                    continue
        
        x=1
        outlist = []
        for i in mergedLoop_list:
            for j in i:
                line = 'loop' + str(x) + '\t' + j + '\t' + str(anchorLayerCountDic[j]) + '\n' 
                outlist.append(line)
            x = x + 1
        outfile = ''.join(outlist)
        with open(f'{out_dir}/tmp/{prefix}.mergedLoop.txt', 'w') as o1:
            o1.write(outfile)


## Remove loops with lower detected-layer frequency than the maximum loops 
## Anchor1 is fixed, anchor2 screening
def FixedFrag1_frag2screen(loop, max_fre, def_frag):

    fixed_frag1, def_frag2 = def_frag.split('\t')
    
    n=1
    exception_state = False
    while 1:
        pre_frag = fixed_frag1 + '\t' + str(int(def_frag2) - (n-1))
        cur_frag = fixed_frag1 + '\t' + str(int(def_frag2) - n)

        if cur_frag in loop:
            if anchorLayerCountDic[cur_frag] == max_fre:
                pass
            elif anchorLayerCountDic[cur_frag] <= anchorLayerCountDic[pre_frag]:
                if anchorLayerCountDic[cur_frag] < anchorLayerCountDic[pre_frag]:
                    exception_state = False
                if cur_frag in outloopList:
                    outloopList.remove(cur_frag)
            else:
                if n == 1:
                    pass
                elif exception == True:
                    except_frag = fixed_frag1 + '\t' + str(int(def_frag2) - (n-2))
                    try:
                        except_fre = anchorLayerCountDic[except_frag]
                    except KeyError:
                        except_fre = 0

                    if exception_state == True:
                        exception_state = False
                        break
                    elif anchorLayerCountDic[cur_frag] <= except_fre:
                        exception_state = True
                        if cur_frag in outloopList:
                            outloopList.remove(cur_frag)
                    else:
                        break
                else:
                    break
        else:
            break
        n = n + 1
    
    n=1
    exception_state = False
    while 1:
        pre_frag = fixed_frag1 + '\t' + str(int(def_frag2) + (n-1))
        cur_frag = fixed_frag1 + '\t' + str(int(def_frag2) + n)

        if cur_frag in loop:
            if anchorLayerCountDic[cur_frag] == max_fre:
                pass
            elif anchorLayerCountDic[cur_frag] <= anchorLayerCountDic[pre_frag]:
                if anchorLayerCountDic[cur_frag] < anchorLayerCountDic[pre_frag]:
                    exception_state = False

                if cur_frag in outloopList:
                    outloopList.remove(cur_frag)
            else:
                if exception == True:
                    except_frag = fixed_frag1 + '\t' + str(int(def_frag2) + (n-2))
                    try:
                        except_fre = anchorLayerCountDic[except_frag]
                    except KeyError:
                        except_fre = 0

                    if exception_state == True:
                        exception_state = False
                        break
                    elif anchorLayerCountDic[cur_frag] <= except_fre:
                        exception_state = True
                        if cur_frag in outloopList:
                            outloopList.remove(cur_frag)
                    else:
                        break
                else:
                    break
        else:
            break
        n = n + 1

## Remove loops with lower detected-layer frequency than the maximum loops 
## Anchor2 is fixed, anchor1 screening
def FixedFrag2_frag1screen(loop, max_fre, def_frag):

    def_frag1, fixed_frag2 = def_frag.split('\t')        

    n=1
    exception_state = False
    while 1:
        pre_frag = str(int(def_frag1) - (n-1)) + '\t' + fixed_frag2
        cur_frag = str(int(def_frag1) - n) + '\t' + fixed_frag2
        if cur_frag in loop:
            if anchorLayerCountDic[cur_frag] == max_fre:
                pass
            elif anchorLayerCountDic[cur_frag] <= anchorLayerCountDic[pre_frag]:
                if anchorLayerCountDic[cur_frag] < anchorLayerCountDic[pre_frag]:
                    exception_state = False
                if cur_frag in outloopList:
                    outloopList.remove(cur_frag)
            else:
                if exception == True:
                    except_frag = str(int(def_frag1) - (n-2)) + '\t' + fixed_frag2
                    try:
                        except_fre = anchorLayerCountDic[except_frag]
                    except KeyError:
                        except_fre = 0

                    if exception_state == True:
                        exception_state = False
                        break
                    elif anchorLayerCountDic[cur_frag] <= except_fre:
                        exception_state = True
                        if cur_frag in outloopList:
                            outloopList.remove(cur_frag)
                    else:
                        break                       
                else:
                    break                                
        else:
            break
        n = n + 1
    
    n=1
    exception_state = False
    while 1:
        pre_frag = str(int(def_frag1) + (n-1)) + '\t' + fixed_frag2
        cur_frag = str(int(def_frag1) + n) + '\t' + fixed_frag2

        if cur_frag in loop:
            if anchorLayerCountDic[cur_frag] == max_fre:
                pass
            elif anchorLayerCountDic[cur_frag] <= anchorLayerCountDic[pre_frag]:
                if anchorLayerCountDic[cur_frag] < anchorLayerCountDic[pre_frag]:
                    exception_state = False
                if cur_frag in outloopList:
                    outloopList.remove(cur_frag)
                    
            else:
                if exception == True:
                    except_frag = str(int(def_frag1) + (n-2)) + '\t' + fixed_frag2
                    try:
                        except_fre = anchorLayerCountDic[except_frag]
                    except KeyError:
                        except_fre = 0

                    if exception_state == True:
                        exception_state = False
                        break
                    elif anchorLayerCountDic[cur_frag] <= except_fre:
                        exception_state = True
                        if cur_frag in outloopList:
                            outloopList.remove(cur_frag)
                    else:
                        break
                else:
                    break
        else:
            break
        n = n + 1

## Find loops with detected-layer frequency among all-connected loops
def detectMaxima(Loop):
    global outloopList
    outloopList = Loop.copy()
    outmaximaLoopList_tmp = []
    
    while 1:
        maxloopList = []
        valueList = []
        
        for a in outloopList:
            valueList.append(anchorLayerCountDic[a])
        max_frequency = max(valueList)
        if max_frequency < cutoff:
            break

        for b in outloopList:
            if anchorLayerCountDic[b] == max_frequency:
                maxloopList.append(b)

        for maxloop in maxloopList:
            frag1,frag2 = maxloop.split('\t')
            outmaximaLoopList_tmp.append(maxloop)

            i=1
            exception_state = False
            while 1:
                
                con_frag1 = str(int(frag1) - (i-1))
                exp_frag1 = str(int(frag1) - i)
                exp_loop = exp_frag1 + '\t' + frag2 

                if exp_loop in Loop:
                    con_frequency = anchorLayerCountDic[con_frag1 + '\t' + frag2]
                    exp_frequency = anchorLayerCountDic[exp_frag1 + '\t' + frag2]
                else:
                    break 

                if exp_frequency == max_frequency:
                    pass
                elif exp_frequency <= con_frequency:
                    if exp_frequency < con_frequency:
                        exception_state = False
                    try:
                        outloopList.remove(exp_loop)
                    except ValueError:
                        pass
                else:
                    if exception == True:
                        except_frag = str(int(frag1) - (i-2)) + '\t' + frag2
                        try:
                            except_frequency = anchorLayerCountDic[except_frag]
                        except KeyError:
                            except_frequency = 0

                        if exception_state == True:
                            exception_state = False
                            break
                        elif exp_frequency <= except_frequency:
                            exception_state = True
                            if exp_loop in outloopList:
                                outloopList.remove(exp_loop)
                        else:
                            break
                    else:
                        break
                
                FixedFrag1_frag2screen(Loop, max_frequency, exp_loop)
                i = i + 1


            i=1
            exception_state = False
            while 1:
                
                con_frag1 = str(int(frag1) + (i-1))
                exp_frag1 = str(int(frag1) + i)
                exp_loop = exp_frag1 + '\t' + frag2 

                if exp_loop in Loop:
                    con_frequency = anchorLayerCountDic[con_frag1 + '\t' + frag2]
                    exp_frequency = anchorLayerCountDic[exp_frag1 + '\t' + frag2]
                else:
                    break 

                if exp_frequency == max_frequency:
                    pass
                elif exp_frequency <= con_frequency:
                    if exp_frequency < con_frequency:
                        exception_state = False
                    try:
                        outloopList.remove(exp_loop)
                    except ValueError:
                        pass
                else:
                    if exception == True:
                        except_frag = str(int(frag1) + (i-2)) + '\t' + frag2
                        try:
                            except_frequency = anchorLayerCountDic[except_frag]
                        except KeyError:
                            except_frequency = 0

                        if exception_state == True:
                            exception_state = False
                            break
                        elif exp_frequency <= except_frequency:
                            exception_state = True
                            if exp_loop in outloopList:
                                outloopList.remove(exp_loop)
                        else:
                            break
                    else:
                        break
                FixedFrag1_frag2screen(Loop, max_frequency, exp_loop)
                i = i + 1
            
            i=1
            exception_state = False
            while 1:
                
                con_frag2 = str(int(frag2) - (i-1))
                exp_frag2 = str(int(frag2) - i)
                exp_loop = frag1 + '\t' + exp_frag2 

                if exp_loop in Loop:
                    con_frequency = anchorLayerCountDic[frag1 + '\t' + con_frag2]
                    exp_frequency = anchorLayerCountDic[frag1 + '\t' + exp_frag2]
                else:
                    break 

                if exp_frequency == max_frequency:
                    pass
                elif exp_frequency <= con_frequency:
                    if exp_frequency < con_frequency:
                        exception_state = False

                    try:
                        outloopList.remove(exp_loop)
                    except ValueError:
                        pass
                else:
                    if exception == True:
                        except_frag = frag1 + '\t' + str(int(frag2) - (i-2))
                        try:
                            except_frequency = anchorLayerCountDic[except_frag]
                        except KeyError:
                            except_frequency = 0

                        if exception_state == True:
                            exception_state = False
                            break
                        elif exp_frequency <= except_frequency:
                            exception_state = True
                            if exp_loop in outloopList:
                                outloopList.remove(exp_loop)
                        else:
                            break
                    else:
                        break
                
                FixedFrag2_frag1screen(Loop, max_frequency, exp_loop)
                i = i + 1

            i=1
            exception_state = False
            while 1:
                
                con_frag2 = str(int(frag2) + (i-1))
                exp_frag2 = str(int(frag2) + i)
                exp_loop = frag1 + '\t' + exp_frag2 

                if exp_loop in Loop:
                    con_frequency = anchorLayerCountDic[frag1 + '\t' + con_frag2]
                    exp_frequency = anchorLayerCountDic[frag1 + '\t' + exp_frag2]
                else:
                    break 

                if exp_frequency == max_frequency:
                    pass
                elif exp_frequency <= con_frequency:
                    if exp_frequency < con_frequency:
                        exception_state = False

                    try:
                        outloopList.remove(exp_loop)
                    except ValueError:
                        pass
                else:
                    if exception == True:
                        except_frag = frag1 + '\t' + str(int(frag2) + (i-2))
                        try:
                            except_frequency = anchorLayerCountDic[except_frag]
                        except KeyError:
                            except_frequency = 0

                        if exception_state == True:
                            exception_state = False
                            break
                        elif exp_frequency <= except_frequency:
                            exception_state = True
                            if exp_loop in outloopList:
                                outloopList.remove(exp_loop)
                        else:
                            break
                    else:
                        break
                       
                FixedFrag2_frag1screen(Loop, max_frequency, exp_loop)
                i = i + 1

        
        for k in maxloopList:
            outloopList.remove(k)

        if outloopList == []:
            break
            
    return(outmaximaLoopList_tmp)

## Overall process of finding loops
def FindMaxFreLoop():
    with open(f'{out_dir}/tmp/{prefix}.MaximalLoop.tmp', 'w') as o1:
        
        x = 1
        
        for mergedloop in mergedLoop_list:
            
            loop_name = 'loop' + str(x)
            outputlooplist = detectMaxima(mergedloop)
            y = 1
            
            backuplooplist = outputlooplist.copy()
            for outputloop in outputlooplist:
                if outputloop not in backuplooplist:
                    continue
                loop_subname = 'local_' + str(y)
                outline = loop_name + '\t' + loop_subname + '\t' + outputloop + '\t' + str(anchorLayerCountDic[outputloop]) + '\n'
                o1.write(outline)
                
                backuplooplist.remove(outputloop)
                sublooplist = [outputloop]
                candidatelooplist = backuplooplist.copy()

                for otherloop in candidatelooplist:
                    if anchorLayerCountDic[outputloop] > anchorLayerCountDic[otherloop]:
                        break                      
                    elif anchorLayerCountDic[outputloop] == anchorLayerCountDic[otherloop]:
                        y1, y2 = otherloop.split('\t')
                        for subloop in sublooplist:
                            z1, z2 = subloop.split('\t')
                            
                            if abs(int(y1) - int(z1)) + abs(int(y2) - int(z2)) == 1:
                                outline = loop_name + '\t' + loop_subname + '\t' + otherloop + '\t' + str(anchorLayerCountDic[otherloop]) + '\n'
                                o1.write(outline)
                                backuplooplist.remove(otherloop)
                                sublooplist.append(otherloop)
                                break
                y += 1 
            x = x + 1

## Re-merge the loops with maximum detected-layer frequencies (equal anchor1, connected anchor2)
def bin2_merge():
    with open(f'{out_dir}/tmp/{prefix}.MaximalLoop.tmp') as f1, open(f'{out_dir}/tmp/{prefix}.bin2merged.tmp','w') as b1:
        context1 = f1.readlines()
        completed_looplist = []
        x=0
        
        while x <= len(context1) - 1:
            
            x1_loop, x1_local_loop, x1_bin1, x1_bin2, x1_freq = context1[x].rstrip().split('\t')

            if x1_loop + '\t' + x1_local_loop + '\t' + x1_bin1 not in completed_looplist:
                completed_looplist.append(x1_loop + '\t' + x1_local_loop + '\t' + x1_bin1)
            
                bin2_start = x1_bin2
                bin2_end = x1_bin2
            
            if x == len(context1) -1:
                outline = x1_loop + '\t' + x1_local_loop + '\t' + x1_bin1 + '\t' + bin2_start + '\t' + bin2_end + '\t' + x1_freq + '\n'
                b1.write(outline)
                break
            
            x2_loop, x2_local_loop, x2_bin1, x2_bin2, x2_freq = context1[x+1].rstrip().split('\t')          
            
            if x2_loop != x1_loop or x2_local_loop != x1_local_loop or x2_bin1 != x1_bin1 or int(x2_bin2) - int(x1_bin2) != 1:
                outline = x1_loop + '\t' + x1_local_loop + '\t' + x1_bin1 + '\t' + bin2_start + '\t' + bin2_end + '\t' + x1_freq + '\n'
                b1.write(outline)
            else:
                bin2_end = x2_bin2

            x += 1

## Re-merge the loops with maximum detected-layer frequencies (equal anchor2, connected anchor1)
def bin1_merge():
    
    with open(f'{out_dir}/tmp/{prefix}.bin2merged.tmp') as f2, open(f'{out_dir}/tmp/{prefix}.bin1merged.tmp','w') as b2:
        context1 = f2.readlines()
        completed_looplist = []
        x=0
        while x <= len(context1) -1:
            
            x1_loop, x1_local_loop, x1_bin1, x1_bin2_start, x1_bin2_end, x1_freq = context1[x].rstrip().split('\t')

            
            if x1_loop + '\t' + x1_local_loop + '\t' + x1_bin2_start + '\t' + x1_bin2_end not in completed_looplist:
                completed_looplist.append(x1_loop + '\t' + x1_local_loop + '\t' + x1_bin2_start + '\t' + x1_bin2_end)
            
                bin1_start = x1_bin1
                bin1_end = x1_bin1
                     
            if x == len(context1) -1:
                outline = x1_loop + '\t' + x1_local_loop + '\t' + bin1_start + '\t' + bin1_end + '\t' + x1_bin2_start + '\t' + x1_bin2_end + '\t' + x1_freq + '\n'
                b2.write(outline)
                break

            x2_loop, x2_local_loop, x2_bin1, x2_bin2_start, x2_bin2_end, x2_freq = context1[x+1].rstrip().split('\t')          
            
            if x2_loop != x1_loop or x2_local_loop != x1_local_loop or x2_bin2_start != x1_bin2_start or x2_bin2_end != x1_bin2_end or int(x2_bin1) - int(x1_bin1) != 1:
                outline = x1_loop + '\t' + x1_local_loop + '\t' + bin1_start + '\t' + bin1_end + '\t' + x1_bin2_start + '\t' + x1_bin2_end + '\t' + x1_freq + '\n'
                b2.write(outline)
            else:
                bin1_end = x2_bin1    

            x += 1
## Convert the fragment information to genomic position
def BinToPos():
    with open(f'{out_dir}/tmp/{prefix}.bin1merged.tmp') as m1, open(f'{out_dir}/{prefix}.HiCORE_out.txt','w') as o2:
        for line in m1:
            loop, subloop, bin1_start, bin1_end, bin2_start, bin2_end, frequency = line.rstrip().split('\t')
            outline = '\t'.join(NumFragDic[bin1_start].split('\t')[0:2]) + '\t' + NumFragDic[bin1_end].split('\t')[2] + '\t' + '\t'.join(NumFragDic[bin2_start].split('\t')[0:2]) + '\t' + NumFragDic[bin2_end].split('\t')[2] + '\t' + loop + '\t' + subloop + '\t' + frequency + '\n'
            o2.write(outline)

if __name__ == '__main__':
    tmpClearing()
    
    if t>1:
        pool = multiprocessing.Pool(processes=t)
        pool.starmap(splitloop, zip(bed_list, overbed_list, loop_list))
        pool.close()
        pool.join()
    else:
        for bed_file, overbed_file, loop_file in zip(bed_list, overbed_list, loop_list):
            splitloop(bed_file, overbed_file, loop_file)
    FragmentDic()
    collectLoop()
    DefineAnchor()
    FindMaxFreLoop()
    bin2_merge()
    bin1_merge()
    BinToPos()
    sp.call(f'rm -r {out_dir}/tmp/{prefix}.*', shell=True, universal_newlines=True)
    if os.listdir(f'{out_dir}/tmp') == []:
        sp.call(f'rm -r {out_dir}/tmp', shell=True, universal_newlines=True)
