#!/usr/bin/env python3
import subprocess as sp
import argparse
import os
import multiprocessing
import argcomplete
import numpy as np

parser = argparse.ArgumentParser(description = '', formatter_class = argparse.RawTextHelpFormatter)

parser.add_argument('-l', dest = 'loop_list', required=True, type = str, help = 
'''loop list file cut by certain criteria, such as q<0.01.
Each file must include (chr1, bin1_start, bin2_start, chr2, chr2_start, chr2_end)
in their first 6 columns.

''')
parser.add_argument('-b', dest = 'bed_list', required=True, type = str, help = 
'''".bed" list file. The order of list must correct with loop list order.
With default setting, bed files are generated in "out_dir/tmp" directory.

''')
parser.add_argument('-o', dest = 'overlapbed_list', required=True, type = str, help = 
'''"overlap_bin.bed" list file. The order of list must correct with loop list order.
With default setting, "overlap_bin.bed" files are generated in "out_dir/tmp" directory.

''')
parser.add_argument('-p', dest = 'prefix', required=True, help = 
'''Output file name prefix. Output file path = {out_dir}/{prefix}.HiCORE_out.txt

''')
parser.add_argument('-d', dest = 'output_dir', default = './', help = '''Path to output directory. (default = "./")

''')
parser.add_argument('-t', dest = 'threads', default = 1, type=int, help = 
'''Number of threads. 
If thread >= layers, the running time is remarkably reduced but memory-intensive. (default = 1)

''')
parser.add_argument('-x', dest = 'cutoff', default = 0.20, type=float, help = '''The minimum detected-layer frequency of loops. (the number of detected layers / total layers). 0<=x<=1, default = 0.2

''')
parser.add_argument('-u', dest = 'unit_bed', required=True, help = '''1f_unit.bed file path. The file was generated by hicbinning.py at outdir/tmp directory

''')
parser.add_argument('-e', dest = 'exception', action='store_true', help = 
'''Except the loops with potential noise. 
With this option, HiCORE identifies the loops with the local maximum detected-layer frequency more strictly.
We recommand to use this option for more stringent analysis.

''')
argcomplete.autocomplete(parser)
args = parser.parse_args()


## Variables
bed_list_file = args.bed_list
loop_list_file = args.loop_list
overbed_list_file = args.overlapbed_list
out_dir = args.output_dir
prefix = args.prefix
t = args.threads
cutoff = args.cutoff
unit_bed = args.unit_bed
exception = args.exception

split_loop_list = []
binSizelist = []

with open(f'{bed_list_file}') as b1:
    bed_list = b1.readlines()
    first_layer_bed = bed_list[0].strip()
with open(f'{loop_list_file}') as l1:
    loop_list = l1.readlines()
    layer_num = len(loop_list)
    split_loop_list = []
    for filename in loop_list:
        split_loop_file = filename.strip() + '.splitbin.txt'
        split_loop_list.append(split_loop_file)
with open(f'{overbed_list_file}') as o1:
    overbed_list = o1.readlines()
    first_layer_overbed = overbed_list[0].strip()


def tmpClearing():
    if os.path.isdir(f'{out_dir}') == True:
        if os.path.isdir(f'{out_dir}/tmp') == False:
            os.mkdir(f'{out_dir}/tmp')
    else:
        os.mkdir(f'{out_dir}')
        os.mkdir(f'{out_dir}/tmp')


## Split the multi-fragments resolution loop files into single fragment resolution
def splitloop(bed_file, overbed_file, loop_file):
    mid_to_binnum = {}
    front_tag = '.'.join(loop_file.split('.')[:-1])

    ### mid point of loop : bin_num dictionary creation
    with open(f'{bed_file}'.strip()) as b1:
        bed_context = b1.readlines()

        for blines in bed_context:
    
            bsplit = blines.split('\t')
            chr_name = bsplit[0]
            mid_point = str(int((int(bsplit[1])+int(bsplit[2]))/2))
            bin_num = bsplit[3].strip()
            mid_to_binnum[chr_name + '\t' + mid_point] = bin_num

    ### (a multi-fragments bin number) : (intact bin of split fragments) dictionary  
    with open(f'{overbed_file}'.strip()) as o1:
        ocontext = o1.readlines()
        binnum_to_fulldic = {}
        obin_list = []

        a=0
        while a <= len(ocontext)-1:
            osplit = ocontext[a].split('\t')
            ofull_bin = '\t'.join(ocontext[a].split('\t')[:3])

            if a == 0:
                obin_list=[]
                obin_list.append(ofull_bin)
                obin_num = str(1)
            else:
                if osplit[3].strip() == obin_num:
                    obin_list.append(ofull_bin)
                    if a == len(ocontext)-1:
                        binnum_to_fulldic[obin_num] = obin_list
                        break
                else:
                    binnum_to_fulldic[obin_num] = obin_list
                    obin_list=[]
                    obin_num = osplit[3].strip()
                    obin_list.append(ofull_bin)
            
            a += 1

    with open(f'{loop_file}'.strip()) as l1:
        loop_context = l1.readlines()
        filename = loop_file.strip()
        writefinal = open(f'{filename}.splitbin.txt','w')

        for llines in loop_context:
            bin1 = '\t'.join(llines.split('\t')[:2])
            bin2 = '\t'.join(llines.split('\t')[2:4])

            full_bin1 = mid_to_binnum[bin1]
            full_bin2 = mid_to_binnum[bin2]

            for i in binnum_to_fulldic[full_bin1]:
                for j in binnum_to_fulldic[full_bin2]:
                    full_bin_out = i + '\t' + j + '\n'
                    writefinal.write(full_bin_out)

        writefinal.close()

## Collect all split loops
def collectLoop():
    cat_loop = ' '.join(split_loop_list)
    sp.call(f"cat {cat_loop} | sort -k1,1 -k2,2n -k5,5n | uniq -c | awk '{{print $2, $3, $4, $5, $6, $7, $1/{layer_num}}}' OFS='\t' > {out_dir}/tmp/{prefix}.allLoop.txt", shell=True, universal_newlines=True)

## Dictionary for genomic information : fragment of restriction fragments
def FragmentDic():
    global FragNumDic, NumFragDic  
    FragNumDic = {}
    NumFragDic = {}
    with open(unit_bed) as u1:
        for line in u1:
            fragment = '\t'.join(line.rstrip().split('\t')[0:3])
            number = line.rstrip().split('\t')[3]
            FragNumDic[fragment] = number
            NumFragDic[number] = fragment

## Merge all the connected loops
def DefineAnchor():
    global anchorLayerCountDic
    anchorLayerCountDic = {}
    loopList = []
    with open(f'{out_dir}/tmp/{prefix}.allLoop.txt') as l1:
        tmplist = []
        for line in l1:
            chr1, start1, end1, chr2, start2, end2, frequency = line.rstrip().split('\t')
            bin1 = FragNumDic[chr1 + '\t' + start1 + '\t' + end1]
            bin2 = FragNumDic[chr2 + '\t' + start2 + '\t' + end2]
            anchorLayerCountDic[bin1 + '\t' + bin2] = float(frequency)

            fixed_anchor = 'anchor1_' + bin1

            if tmplist == []:
                tmplist = [fixed_anchor,bin2]
            else:
                anchor1 = tmplist[0]
                anchor2 = int(tmplist[-1])

                if bin1 == anchor1.split('_')[-1] and abs(int(bin2) - anchor2) == 1:
                    tmplist.append(bin2)
                else:
                    loopList.append(tmplist)
                    tmplist = [fixed_anchor, bin2]

        loopList.append(tmplist)
        global mergedLoop_list
        mergedLoop_list = []

        while len(loopList) > 0:
            loop = loopList[0]
            tmplist = []
            startloop = []
            anchor1 = loop[0].split('_')[-1]
            loopList.pop(0)

            if len(loopList) == 0:
                for last_anchor in loop:
                    if 'anchor' not in last_anchor:
                        tmplist.append(anchor1 + '\t' + last_anchor)
                mergedLoop_list.append(tmplist)
                break
            else:
                for anchor2 in loop:
                    if 'anchor' not in anchor2:
                        startloop.append(anchor1 + '\t' + anchor2)
                        tmplist.append(anchor1 + '\t' + anchor2)
            
            a=1
            break_1 = False           
            while 1:
                
                i=0
                while 1:
                    if tmplist == startloop:
                        previous_loop = loop
                    elif i == len(loopList):
                        mergedLoop_list.append(tmplist)
                        break
                    else:
                        previous_loop = tmpanchor2

                    screening_loop = loopList[i]
                    screening_anchor = screening_loop[0].split('_')[-1]

                    if int(screening_anchor) < int(anchor1) + a:
                        i = i + 1
                        continue

                    elif int(screening_anchor) == int(anchor1) + a:
                        for original_anchor2 in previous_loop:
                            if original_anchor2 in screening_loop and 'anchor' not in original_anchor2:

                                ## Merge the neighboring fragments
                                tmpanchor2 = []
                                for next_anchor2 in screening_loop:
                                    if 'anchor' not in next_anchor2:
                                        
                                        tmplist.append(screening_anchor + '\t' + next_anchor2)
                                        tmpanchor2.append(next_anchor2)
                                loopList.remove(screening_loop)        
                                break_1 = True
                                i = i - 1
                                break
                        i = i + 1
                        if len(loopList) == 0:
                            mergedLoop_list.append(tmplist)
                            break
                        continue
                    else:
                        break

                if len(loopList) == 0 or i == len(loopList):
                    break
                elif break_1 == False:
                    mergedLoop_list.append(tmplist)
                    break
                else:
                    a = a + 1
                    break_1 = False
                    continue
        
        x=1
        outlist = []
        for i in mergedLoop_list:
            for j in i:
                line = 'loop' + str(x) + '\t' + j + '\t' + str(anchorLayerCountDic[j]) + '\n' 
                outlist.append(line)
            x = x + 1
        outfile = ''.join(outlist)
        with open(f'{out_dir}/tmp/{prefix}.mergedLoop.txt', 'w') as o1:
            o1.write(outfile)

## Re-merge the loops with maximum detected-layer frequencies (equal anchor1, connected anchor2)
def bin2_merge_1():
    with open(f'{out_dir}/tmp/{prefix}.mergedLoop.txt') as f1, open(f'{out_dir}/tmp/{prefix}.mergedLoop.bin2merged.tmp','w') as b1:
        context1 = f1.readlines()
        x=0
        while x <= len(context1) - 1:
            
            x1_loop, x1_bin1, x1_bin2, x1_freq = context1[x].rstrip().split('\t')
            bin2_start = x1_bin2
            bin2_end = x1_bin2
            x += 1
            while 1:

                x2_loop, x2_bin1, x2_bin2, x2_freq = context1[x].rstrip().split('\t')
                    
                if x2_loop == x1_loop and x2_bin1 == x1_bin1:
                    if x == len(context1) -1:
                        bin2_end = x2_bin2
                        outline = x1_loop + '\t' + x1_bin1 + '\t' + bin2_start + '\t' + bin2_end + '\n'
                        b1.write(outline)
                        break
                    elif int(x2_bin2) - int(bin2_end) == 1:
                        bin2_end = x2_bin2
                    else:
                        outline = x1_loop + '\t' + x1_bin1 + '\t' + bin2_start + '\t' + bin2_end + '\n'
                        b1.write(outline)
                        break
                else:
                    outline = x1_loop + '\t' + x1_bin1 + '\t' + bin2_start + '\t' + bin2_end + '\n'
                    b1.write(outline)
                    break
                x += 1
            
            if x== len(context1) -1:
                break

## Re-merge the loops with maximum detected-layer frequencies (equal anchor2, connected anchor1)
def bin1_merge_1():
    
    with open(f'{out_dir}/tmp/{prefix}.mergedLoop.bin2merged.tmp') as f2, open(f'{out_dir}/tmp/{prefix}.mergedLoop.bin1merged.tmp','w') as b2:
        context1 = f2.readlines()
        
        x=0
        while x <= len(context1) - 1:
            
            x1_loop, x1_bin1, x1_bin2_start, x1_bin2_end = context1[x].rstrip().split('\t')
            bin1_start = x1_bin1
            bin1_end = x1_bin1
            x += 1
            while 1:

                x2_loop, x2_bin1, x2_bin2_start, x2_bin2_end = context1[x].rstrip().split('\t')
                    
                if x2_loop == x1_loop and x2_bin2_start == x1_bin2_start and x2_bin2_end == x1_bin2_end:
                    if x == len(context1) - 1:
                        bin1_end = x2_bin1
                        outline = x1_loop + '\t' + bin1_start + '\t' + bin1_end + '\t' + x1_bin2_start + '\t' + x1_bin2_end + '\n'
                        b2.write(outline)
                        break
                    elif int(x2_bin1) - int(bin1_end) == 1:
                        bin1_end = x2_bin1
                    else:
                        outline = x1_loop + '\t' + bin1_start + '\t' + bin1_end + '\t' + x1_bin2_start + '\t' + x1_bin2_end + '\n'
                        b2.write(outline)
                        break
                else:
                    outline = x1_loop + '\t' + bin1_start + '\t' + bin1_end + '\t' + x1_bin2_start + '\t' + x1_bin2_end + '\n'
                    b2.write(outline)
                    break
                x += 1
            
            if x== len(context1) -1:
                break

def BinToPos_1():
    with open(f'{out_dir}/tmp/{prefix}.mergedLoop.bin1merged.tmp') as m1, open(f'{out_dir}/{prefix}.HiCORE_AllLoop.txt','w') as o2:
        for line in m1:
            loop, bin1_start, bin1_end, bin2_start, bin2_end = line.rstrip().split('\t')
            outline = '\t'.join(NumFragDic[bin1_start].split('\t')[0:2]) + '\t' + NumFragDic[bin1_end].split('\t')[2] + '\t' + '\t'.join(NumFragDic[bin2_start].split('\t')[0:2]) + '\t' + NumFragDic[bin2_end].split('\t')[2] + '\t' + loop + '\n'
            o2.write(outline)

def GetLoopInfo():

    sp.call(f"less {out_dir}/tmp/{prefix}.mergedLoop.txt | datamash groupby 1 min 2 max 2 min 3 max 3 > {out_dir}/tmp/{prefix}.mergedLoop.datamash.tmp", shell=True, universal_newlines=True)

    global loopStartPosDic, loopArrayDic, loopFreqDic
    loopStartPosDic = {}
    loopArrayDic = {}
    loopFreqDic = {}
    with open(f'{out_dir}/tmp/{prefix}.mergedLoop.txt') as f2:
        for line in f2:
            loop, bin1, bin2, freq = line.rstrip().split('\t')
            loopFreqDic[loop + '\t' + bin1 + '\t' + bin2] = float(freq)

    with open(f'{out_dir}/tmp/{prefix}.mergedLoop.datamash.tmp') as f1:
        for line in f1:
            split1 = line.rstrip().split('\t')
            loop = split1[0]
            bin1_start = int(split1[1])
            bin1_end = int(split1[2])
            bin2_start = int(split1[3])
            bin2_end = int(split1[4])
            loopStartPosDic[loop] = str(bin1_start) + '\t' + str(bin2_start)

            loopArray = np.zeros((bin1_end - bin1_start + 1, bin2_end - bin2_start + 1))
            for i in range(bin1_start, bin1_end+1):
                for j in range(bin2_start, bin2_end+1):
                    try:
                        loopArray[i-bin1_start,j-bin2_start] = loopFreqDic[loop + '\t' + str(i) + '\t' + str(j)]
                    except KeyError:
                        loopArray[i-bin1_start,j-bin2_start] = 0
            
            loopArrayDic[loop] = loopArray



## Remove loops with lower detected-layer frequency than the maximum loops 
## Anchor1 is fixed, anchor2 screening
def FixedFrag1_frag2screen(LoopArray, max_fre, frag1, frag2):
    fixed_frag1 = frag1
    def_frag2 = frag2
    n=1
    exception_state = False
    while 1:
        pre_frag2 = def_frag2 - (n-1)
        cur_frag2 = def_frag2 - n

        if cur_frag2 >= 0:
            pre_fre = LoopArray[fixed_frag1,pre_frag2]
            cur_fre = LoopArray[fixed_frag1,cur_frag2]
            if cur_fre == max_fre:
                pass
            elif cur_fre == 0:
                break
            elif cur_fre <= pre_fre:
                if cur_fre < pre_fre:
                    exception_state = False
                zeroArray[fixed_frag1,cur_frag2] = 0
            else:
                if exception == True:
                    except_frag2 = def_frag2 - (n-2)
                    try:
                        except_fre = LoopArray[fixed_frag1,except_frag2]
                    except IndexError:
                        except_fre = 0
                    
                    if exception_state == True:
                        exception_state = False
                        break
                    elif cur_fre <= except_fre:
                        exception_state = True
                        zeroArray[fixed_frag1,cur_frag2] = 0
                    else:
                        break
                else:
                    break
        else:
            break
        n = n + 1

    n=1
    exception_state = False
    while 1:
        pre_frag2 = def_frag2 + (n-1)
        cur_frag2 = def_frag2 + n

        if cur_frag2 < LoopArray.shape[1]:
            pre_fre = LoopArray[fixed_frag1,pre_frag2]
            cur_fre = LoopArray[fixed_frag1,cur_frag2]
            if cur_fre == max_fre:
                pass
            elif cur_fre == 0:
                break
            elif cur_fre <= pre_fre:
                if cur_fre < pre_fre:
                    exception_state = False
                zeroArray[fixed_frag1,cur_frag2] = 0
            else:
                if exception == True:
                    except_frag2 = def_frag2 + (n-2)
                    try:
                        except_fre = LoopArray[fixed_frag1,except_frag2]
                    except IndexError:
                        except_fre = 0
                    
                    if exception_state == True:
                        exception_state = False
                        break
                    elif cur_fre <= except_fre:
                        exception_state = True
                        zeroArray[fixed_frag1,cur_frag2] = 0
                    else:
                        break
                else:
                    break
        else:
            break
        n = n + 1

## Remove loops with lower detected-layer frequency than the maximum loops 
## Anchor2 is fixed, anchor1 screening
def FixedFrag2_frag1screen(LoopArray, max_fre, frag1, frag2):
    def_frag1 = frag1
    fixed_frag2 = frag2

    n=1
    exception_state = False
    while 1:
        pre_frag1 = def_frag1 - (n-1)
        cur_frag1 = def_frag1 - n

        if cur_frag1 >= 0:
            pre_fre = LoopArray[pre_frag1,fixed_frag2]
            cur_fre = LoopArray[cur_frag1,fixed_frag2]

            if cur_fre == max_fre:
                pass
            elif cur_fre == 0:
                break
            elif cur_fre <= pre_fre:
                if cur_fre < pre_fre:
                    exception_state = False
                zeroArray[cur_frag1,fixed_frag2] = 0
            else:

                if exception == True:
                    except_frag1 = def_frag1 - (n-2)
                    try:
                        except_fre = LoopArray[except_frag1,fixed_frag2]
                    except IndexError:
                        except_fre = 0
                    
                    if exception_state == True:
                        exception_state = False
                        break
                    elif cur_fre <= except_fre:
                        exception_state = True
                        zeroArray[cur_frag1,fixed_frag2] = 0
                       
                    else:
                        break
                else:
                    break
        else:
            break
        n = n + 1

    n=1
    exception_state = False
    while 1:
        pre_frag1 = def_frag1 + (n-1)
        cur_frag1 = def_frag1 + n

        if cur_frag1 < LoopArray.shape[0]:
            pre_fre = LoopArray[pre_frag1,fixed_frag2]
            cur_fre = LoopArray[cur_frag1,fixed_frag2]
            if cur_fre == max_fre:
                pass
            elif cur_fre == 0:
                break
            elif cur_fre <= pre_fre:
                if cur_fre < pre_fre:
                    exception_state = False
                zeroArray[cur_frag1,fixed_frag2] = 0
                
            else:

                if exception == True:
                    except_frag1 = def_frag1 + (n-2)
                    try:
                        except_fre = LoopArray[except_frag1,fixed_frag2]
                    except IndexError:
                        except_fre = 0
                    
                    if exception_state == True:
                        exception_state = False
                        break
                    elif cur_fre <= except_fre:
                        exception_state = True
                        zeroArray[cur_frag1,fixed_frag2] = 0
                        
                    else:
                        break
                else:
                    break
        else:
            break
        n = n + 1    

## Find loops with detected-layer frequency among all-connected loops
def detectMaxima(Loop):
    global zeroArray
    Array = loopArrayDic[Loop]
    zeroArray = Array.copy()
    outmaximaLoopList_tmp = []

    while 1:
        maxloopList = []
        max_frequency = np.max(zeroArray)
        if max_frequency < cutoff:
            break
        maxloopList = []
        maxloopIndex = np.where(zeroArray == max_frequency)
        for i in range(0,len(maxloopIndex[0])):
            maxloopList.append(str(maxloopIndex[0][i]) + '\t' + str(maxloopIndex[1][i]))
        
        for maxloop in maxloopList:
            
            frag1 = int(maxloop.split('\t')[0])
            frag2 = int(maxloop.split('\t')[1])

            outloop = str(frag1 + int(loopStartPosDic[Loop].split('\t')[0])) + '\t' + str(frag2 + int(loopStartPosDic[Loop].split('\t')[1]))
            outmaximaLoopList_tmp.append(outloop)
            
            i=1
            exception_state = False
            while 1:
                
                con_frag1 = frag1 - (i-1)
                exp_frag1 = frag1 - i

                if exp_frag1 >= 0:
                    con_frequency = Array[con_frag1,frag2]
                    exp_frequency = Array[exp_frag1,frag2]
                else:
                    break 

                if exp_frequency == max_frequency:
                    pass
                elif exp_frequency == 0:
                    break
                elif exp_frequency <= con_frequency:
                    if exp_frequency < con_frequency:
                        exception_state = False
                    zeroArray[exp_frag1,frag2] = 0
                else:
                    if exception == True:
                        except_frag1 = frag1 - (i-2) 
                        try:
                            except_frequency = Array[except_frag1,frag2]
                        except IndexError:
                            except_frequency = 0

                        if exception_state == True:
                            exception_state = False
                            break
                        elif exp_frequency <= except_frequency:
                            exception_state = True
                            zeroArray[exp_frag1,frag2] = 0
                        else:
                            break
                    else:
                        break

                FixedFrag1_frag2screen(Array, max_frequency, exp_frag1, frag2)
                i = i + 1


            i=1
            exception_state = False
            while 1:
                
                con_frag1 = frag1 + (i-1)
                exp_frag1 = frag1 + i

                if exp_frag1 < Array.shape[0]:
                    con_frequency = Array[con_frag1,frag2]
                    exp_frequency = Array[exp_frag1,frag2]
                else:
                    break 
                
                if exp_frequency == max_frequency:
                    pass
                elif exp_frequency == 0:
                    break
                elif exp_frequency <= con_frequency:
                    if exp_frequency < con_frequency:
                        exception_state = False
                    zeroArray[exp_frag1,frag2] = 0
                else:
                    if exception == True:
                        except_frag1 = frag1 + (i-2) 
                        try:
                            except_frequency = Array[except_frag1,frag2]
                        except IndexError:
                            except_frequency = 0
                        if exception_state == True:
                            exception_state = False
                            break
                        elif exp_frequency <= except_frequency:
                            exception_state = True
                            zeroArray[exp_frag1,frag2] = 0
                        else:
                            break
                    else:
                        break
          
                FixedFrag1_frag2screen(Array, max_frequency, exp_frag1, frag2)
                i = i + 1                            

            i=1
            exception_state = False
            while 1:
                con_frag2 = frag2 - (i-1)
                exp_frag2 = frag2 - i                
                
                if exp_frag2 >= 0:
                    con_frequency = Array[frag1,con_frag2]
                    exp_frequency = Array[frag1,exp_frag2]                
                else:
                    break                  
                if exp_frequency == max_frequency:
                    pass
                elif exp_frequency == 0:
                    break
                elif exp_frequency <= con_frequency:
                    if exp_frequency < con_frequency:
                        exception_state = False
                    zeroArray[frag1,exp_frag2] = 0
                else:
                    if exception == True:
                        except_frag2 = frag2 - (i-2) 
                        try:
                            except_frequency = Array[frag1,except_frag2]
                        except IndexError:
                            except_frequency = 0
                        if exception_state == True:
                            exception_state = False
                            break
                        elif exp_frequency <= except_frequency:
                            exception_state = True
                            zeroArray[frag1,exp_frag2] = 0
                        else:
                            break
                    else:
                        break
              
                FixedFrag2_frag1screen(Array, max_frequency, frag1, exp_frag2)
                i = i + 1  
            
            i=1
            exception_state = False
            while 1:
                con_frag2 = frag2 + (i-1)
                exp_frag2 = frag2 + i                
                
                if exp_frag2 < Array.shape[1]:
                    con_frequency = Array[frag1,con_frag2]
                    exp_frequency = Array[frag1,exp_frag2]                
                else:
                    break      

                if exp_frequency == max_frequency:
                    pass
                elif exp_frequency == 0:
                    break
                elif exp_frequency <= con_frequency:
                    if exp_frequency < con_frequency:
                        exception_state = False
                    zeroArray[frag1,exp_frag2] = 0
                else:
                    if exception == True:
                        except_frag2 = frag2 + (i-2) 
                        try:
                            except_frequency = Array[frag1,except_frag2]
                        except IndexError:
                            except_frequency = 0
                        if exception_state == True:
                            exception_state = False
                            break
                        elif exp_frequency <= except_frequency:
                            exception_state = True
                            zeroArray[frag1,exp_frag2] = 0
                        else:
                            break
                    else:
                        break

                FixedFrag2_frag1screen(Array, max_frequency, frag1, exp_frag2)
                i = i + 1  
        zeroArray = np.where(zeroArray==max_frequency,0,zeroArray)
        if np.max(zeroArray) == 0:
            break

    return(outmaximaLoopList_tmp)

## Overall process of finding loops
def FindMaxFreLoop():
    with open(f'{out_dir}/tmp/{prefix}.MaximalLoop.tmp', 'w') as o1:
        x = 1
        for loop in loopArrayDic:

            outputlooplist = detectMaxima(loop)
            y = 1
            backuplooplist = outputlooplist.copy()
            for outputloop in outputlooplist:
                if outputloop not in backuplooplist:
                    continue
                loop_subname = 'local_' + str(y)
                outline = loop + '\t' + loop_subname + '\t' + outputloop + '\t' + str(loopFreqDic[loop + '\t' + outputloop]) + '\n'
                o1.write(outline)
                backuplooplist.remove(outputloop)
                sublooplist = [outputloop]
                candidatelooplist = backuplooplist.copy()
                for otherloop in candidatelooplist:
                    if loopFreqDic[loop + '\t' + outputloop] > loopFreqDic[loop + '\t' + otherloop]:
                        break                      
                    elif loopFreqDic[loop + '\t' + outputloop] == loopFreqDic[loop + '\t' + otherloop]:
                        y1, y2 = otherloop.split('\t')
                        for subloop in sublooplist:
                            z1, z2 = subloop.split('\t')
                            if abs(int(y1) - int(z1)) + abs(int(y2) - int(z2)) == 1:
                                outline = loop + '\t' + loop_subname + '\t' + otherloop + '\t' + str(loopFreqDic[loop + '\t' + otherloop]) + '\n'
                                o1.write(outline)
                                backuplooplist.remove(otherloop)
                                sublooplist.append(otherloop)
                                break
                y += 1 
            x = x + 1


## Re-merge the loops with maximum detected-layer frequencies (equal anchor2, connected anchor1)
def bin1_merge_1():
    
    with open(f'{out_dir}/tmp/{prefix}.mergedLoop.bin2merged.tmp') as f2, open(f'{out_dir}/tmp/{prefix}.mergedLoop.bin1merged.tmp','w') as b2:
        context1 = f2.readlines()
        
        x=0
        while x <= len(context1) - 1:
            
            x1_loop, x1_bin1, x1_bin2_start, x1_bin2_end = context1[x].rstrip().split('\t')
            bin1_start = x1_bin1
            bin1_end = x1_bin1
            x += 1
            while 1:

                x2_loop, x2_bin1, x2_bin2_start, x2_bin2_end = context1[x].rstrip().split('\t')
                    
                if x2_loop == x1_loop and x2_bin2_start == x1_bin2_start and x2_bin2_end == x1_bin2_end:
                    if x == len(context1) - 1:
                        bin1_end = x2_bin1
                        outline = x1_loop + '\t' + bin1_start + '\t' + bin1_end + '\t' + x1_bin2_start + '\t' + x1_bin2_end + '\n'
                        b2.write(outline)
                        break
                    elif int(x2_bin1) - int(bin1_end) == 1:
                        bin1_end = x2_bin1
                    else:
                        outline = x1_loop + '\t' + bin1_start + '\t' + bin1_end + '\t' + x1_bin2_start + '\t' + x1_bin2_end + '\n'
                        b2.write(outline)
                        break
                else:
                    outline = x1_loop + '\t' + bin1_start + '\t' + bin1_end + '\t' + x1_bin2_start + '\t' + x1_bin2_end + '\n'
                    b2.write(outline)
                    break
                x += 1
            
            if x== len(context1) -1:
                break
## Re-merge the loops with maximum detected-layer frequencies (equal anchor1, connected anchor2)
def bin2_merge_2():
    with open(f'{out_dir}/tmp/{prefix}.MaximalLoop.tmp') as f1, open(f'{out_dir}/tmp/{prefix}.bin2merged.tmp','w') as b1:
        context1 = f1.readlines()
        x=0
        while x <= len(context1) - 1:
            
            x1_loop, x1_local_loop, x1_bin1, x1_bin2, x1_freq = context1[x].rstrip().split('\t')
            bin2_start = x1_bin2
            bin2_end = x1_bin2
            x += 1
            while 1:

                x2_loop, x2_local_loop, x2_bin1, x2_bin2, x2_freq = context1[x].rstrip().split('\t')
                    
                if x2_loop == x1_loop and x2_local_loop == x1_local_loop and x2_bin1 == x1_bin1:
                    if x == len(context1) -1:
                        bin2_end = x2_bin2
                        outline = x1_loop + '\t' + x1_local_loop + '\t' + x1_bin1 + '\t' + bin2_start + '\t' + bin2_end + '\t' + x1_freq + '\n'
                        b1.write(outline)
                        break
                    elif int(x2_bin2) - int(bin2_end) == 1:
                        bin2_end = x2_bin2
                    else:
                        outline = x1_loop + '\t' + x1_local_loop + '\t' + x1_bin1 + '\t' + bin2_start + '\t' + bin2_end + '\t' + x1_freq + '\n'
                        b1.write(outline)
                        break
                else:
                    outline = x1_loop + '\t' + x1_local_loop + '\t' + x1_bin1 + '\t' + bin2_start + '\t' + bin2_end + '\t' + x1_freq + '\n'
                    b1.write(outline)
                    break
                x += 1
            
            if x== len(context1) -1:
                break


## Re-merge the loops with maximum detected-layer frequencies (equal anchor2, connected anchor1)
def bin1_merge_2():
    
    with open(f'{out_dir}/tmp/{prefix}.bin2merged.tmp') as f2, open(f'{out_dir}/tmp/{prefix}.bin1merged.tmp','w') as b2:
        context1 = f2.readlines()
        
        x=0
        while x <= len(context1) - 1:
            
            x1_loop, x1_local_loop, x1_bin1, x1_bin2_start, x1_bin2_end, x1_freq = context1[x].rstrip().split('\t')
            bin1_start = x1_bin1
            bin1_end = x1_bin1
            x += 1
            while 1:

                x2_loop, x2_local_loop, x2_bin1, x2_bin2_start, x2_bin2_end, x2_freq = context1[x].rstrip().split('\t')
                    
                if x2_loop == x1_loop and x2_local_loop == x1_local_loop and x2_bin2_start == x1_bin2_start and x2_bin2_end == x1_bin2_end:
                    if x == len(context1) - 1:
                        bin1_end = x2_bin1
                        outline = x1_loop + '\t' + x1_local_loop + '\t' + bin1_start + '\t' + bin1_end + '\t' + x1_bin2_start + '\t' + x1_bin2_end + '\t' + x1_freq + '\n'
                        b2.write(outline)
                        break
                    elif int(x2_bin1) - int(bin1_end) == 1:
                        bin1_end = x2_bin1
                    else:
                        outline = x1_loop + '\t' + x1_local_loop + '\t' + bin1_start + '\t' + bin1_end + '\t' + x1_bin2_start + '\t' + x1_bin2_end + '\t' + x1_freq + '\n'
                        b2.write(outline)
                        break
                else:
                    outline = x1_loop + '\t' + x1_local_loop + '\t' + bin1_start + '\t' + bin1_end + '\t' + x1_bin2_start + '\t' + x1_bin2_end + '\t' + x1_freq + '\n'
                    b2.write(outline)
                    break
                x += 1
            
            if x== len(context1) -1:
                break

                     
## Convert the fragment information to genomic position
def BinToPos_2():
    with open(f'{out_dir}/tmp/{prefix}.bin1merged.tmp') as m1, open(f'{out_dir}/{prefix}.HiCORE_out.txt','w') as o2:
        for line in m1:
            loop, subloop, bin1_start, bin1_end, bin2_start, bin2_end, frequency = line.rstrip().split('\t')
            outline = '\t'.join(NumFragDic[bin1_start].split('\t')[0:2]) + '\t' + NumFragDic[bin1_end].split('\t')[2] + '\t' + '\t'.join(NumFragDic[bin2_start].split('\t')[0:2]) + '\t' + NumFragDic[bin2_end].split('\t')[2] + '\t' + loop + '\t' + subloop + '\t' + frequency + '\n'
            o2.write(outline)

if __name__ == '__main__':
    tmpClearing()
    
    if t>1:
        pool = multiprocessing.Pool(processes=t)
        pool.starmap(splitloop, zip(bed_list, overbed_list, loop_list))
        pool.close()
        pool.join()
    else:
        for bed_file, overbed_file, loop_file in zip(bed_list, overbed_list, loop_list):
            splitloop(bed_file, overbed_file, loop_file)
    FragmentDic()
    collectLoop()
    DefineAnchor()
    bin2_merge_1()
    bin1_merge_1()
    BinToPos_1()
    GetLoopInfo()
    FindMaxFreLoop()
    bin2_merge_2()
    bin1_merge_2()
    BinToPos_2()
    #sp.call(f'rm -r {out_dir}/tmp/{prefix}.*', shell=True, universal_newlines=True)
    if os.listdir(f'{out_dir}/tmp') == []:
        sp.call(f'rm -r {out_dir}/tmp', shell=True, universal_newlines=True)
